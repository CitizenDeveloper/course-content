# description

Business users and programmers have a hard time communicating because of a fundamental difference in perspective.  On the one hand, software must be built quickly and meet requirements if it is to be of any value to the business.  On the other hand, speed of development and complexity (ie. many requirements) are two opposing forces in the mind of a programmer.

In this module you will learn how programmers think about solving problems and witness a small sampling of programming activities first hand.

# learning objectives

By the end of this module you will be able to:

- Describe the challenges of software engineering and software quality management
- Empathize with the developers in your organization struggle with the empirical nature of software development
- Recognize patterns in software development which can help you communicate more effectively with programmers
- Engage in technical conversations about execution context and artifacts

# agenda:

[Understanding Software Engineering](/activity-4-1)
[Understanding Software Quality](/activity-4-2)
[Understanding Software Programming](/activity-4-3)
[Understanding Software Execution Artifacts and Context](/activity-4-4)

# pair and share

### Consider your own experiences working with software developers

- Do you appreciate something new about why a software project may have been delayed?
- Is there something you might change about the way in which your company engages programmers in their work?
- How could you help improve software quality at your organization?

### Consider your own interests in learning to write software

- Does the prospect of developing software yourself seem more or less attractive to you now than it did before this module?
- Which programming language would you choose to learn if you decided to write your own software?

# success criteria

- I can describe some of the processes and principles of software engineering 
- I can discuss various aspects of software quality and how they relate to my business
- I can articulate the main concepts behind test driven development and recognize it when I see it
- I understand the difference between client-side and server-side code
- I know where to find open source software that I can repurpose to suit my needs if I so choose
